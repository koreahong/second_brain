---
title: 비동기 코드 작성
type: resource
---

## 개념

- 비동기처리도 트랜잭션과 비슷하게 한개에서 에러가 발생하면 전체를 취소할 수 있고 아니면 개별로 따로 결과값을 가져오게 할 수 ㅣㅇㅆ음
## 목적

- 비동기 처리시 에러관리를 하기 위함
## 서칭내용

비동기 처리 시 하나의 작업이 실패할 때 전체 배치가 실패하는지 여부는 process_batch 함수 내부에서 어떻게 비동기 작업을 관리하는지에 따라 달라집니다. 일반적으로 Python의 asyncio 라이브러리를 사용할 때, asyncio.gather를 통해 여러 비동기 작업을 동시에 실행할 수 있습니다. 그러나 asyncio.gather의 기본 동작은 첫 번째 예외가 발생하면 남은 모든 작업을 취소하고 예외를 던진다는 점입니다.

### 기본 asyncio.gather 동작

```python
python
코드 복사
import asyncio

async def task1():
    # 작업 1 수행
    pass

async def task2():
    # 작업 2 수행
    raise Exception("오류 발생")

async def process_batch(event):
    tasks = [task1(), task2()]
    results = await asyncio.gather(*tasks)  # 여기서 task2가 예외를 발생시키면

```

위 예제에서 task2가 예외를 발생시키면 asyncio.gather는 즉시 예외를 던지고, task1도 취소됩니다. 따라서 배치 내의 다른 모든 작업도 실패하게 됩니다.

### 예외를 개별적으로 처리하는 방법

만약 배치 내의 각 작업이 독립적으로 처리되고, 하나의 작업 실패가 전체 배치 실패로 이어지지 않도록 하려면, 각 작업 내에서 예외를 처리하거나 asyncio.gather의 return_exceptions 파라미터를 사용해야 합니다.

### 1. 각 작업 내에서 예외 처리

```python
python
코드 복사
async def safe_task(record):
    try:
        # 실제 작업 수행
        await execute_record(record)
    except Exception as e:
        # 예외 로깅 또는 개별 처리
        print(f"Record 처리 중 오류 발생: {e}")
        return None  # 또는 적절한 기본값 반환

async def process_batch(event):
    tasks = [safe_task(record) for record in event["Records"]]
    results = await asyncio.gather(*tasks)
    # results에는 성공한 결과와 None(또는 기본값)이 포함됨

```

### 2. asyncio.gather에서 return_exceptions=True 사용

```python
python
코드 복사
async def execute_record(record):
    # 실제 작업 수행
    pass

async def process_batch(event):
    tasks = [execute_record(record) for record in event["Records"]]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    for result in results:
        if isinstance(result, Exception):
            # 예외 로깅 또는 개별 처리
            print(f"Record 처리 중 오류 발생: {result}")
        else:
            # 성공한 결과 처리
            pass

```

### 결론

현재 비동기 처리 방식(asyncio.run(process_batch(event)))에서 process_batch 함수가 asyncio.gather를 사용하여 예외를 처리하지 않는다면, 하나의 레코드 처리 실패가 전체 배치를 실패시키는 원인이 될 수 있습니다. 이를 방지하려면 각 비동기 작업 내에서 예외를 개별적으로 처리하거나 asyncio.gather의 return_exceptions=True 옵션을 활용하여 전체 배치가 하나의 실패로 인해 중단되지 않도록 해야 합니다.

### 추가 팁

- 로깅: 각 예외를 로깅하여 나중에 문제를 분석할 수 있도록 하는 것이 좋습니다.
- 재시도 로직: 특정 예외에 대해서는 재시도 로직을 추가하여 일시적인 오류를 극복할 수 있습니다.
- 배치 결과 처리: 모든 작업이 완료된 후, 성공한 작업과 실패한 작업을 구분하여 후속 처리를 할 수 있도록 설계하는 것이 유용합니다.
이러한 접근 방식을 통해 하나의 레코드 실패가 전체 배치 처리에 영향을 미치지 않도록 안정적인 비동기 처리를 구현할 수 있습니다.

---

예시 코드:

```python
python
코드 복사
import asyncio
import json

async def execute_record(record):
    # 예시: JSON 파싱 및 작업 수행
    data = json.loads(record)
    # 여기서 실제 데이터베이스 업서트 로직 수행
    if data["a"] == 2:
        raise ValueError("예시 오류")
    return data

async def process_batch(event):
    tasks = [execute_record(record) for record in event["Records"]]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    for i, result in enumerate(results):
        if isinstance(result, Exception):
            print(f"Record {i} 처리 실패: {result}")
        else:
            print(f"Record {i} 처리 성공: {result}")

if __name__ == "__main__":
    event = {
        "Records": [
            '{"mallid": "aivelabs", "target_db": "wahs", "table_name": "test", "schema": "temp", "operation": "execute_upsert", "data": [{"a": 1, "b": 4}]}',
            '{"mallid": "aivelabs", "target_db": "wahs", "table_name": "test", "schema": "temp", "operation": "execute_upsert", "data": [{"a": 2, "b": 3}]}',
        ]
    }
    asyncio.run(process_batch(event))

```

출력:

```css
css
코드 복사
Record 0 처리 성공: {'mallid': 'aivelabs', 'target_db': 'wahs', 'table_name': 'test', 'schema': 'temp', 'operation': 'execute_upsert', 'data': [{'a': 1, 'b': 4}]}
Record 1 처리 실패: ValueError('예시 오류')

```

이 예시에서는 첫 번째 레코드는 성공하고, 두 번째 레코드는 의도적으로 오류를 발생시켜 개별적으로 처리되는 모습을 보여줍니다.