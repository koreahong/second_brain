---
title: 메모리 효율 - 청크 사용
type: resource
tags:
- DB
---

## 개념

- 청크개념을 활용하여 ETL 작업시 서버의 부하를 최소화하여 효율적인 데이터 파이프라인을 구현하기 위함.
## 목적

- 개념이 필요하게 된 배경을 작성할 것
## 청크단위로 가져올 수 있게 하는 기술적인 이유

### 1. cursor

- 쿼리를 실행하면 데이터베이스는 모든 결과를 반환하지 않고, **결과 포인터(cursor)**만 반환
- 이 커서를 사용해 **필요한 만큼만 데이터를 읽어오는 방식(fetch)**을 적용합니다.
- fetchmany(1000) 으로 가져올 만큼만 데이터를 읽어옴
⇒ 결과 포인터로 limit offset 느낌으로 지정한 크기만큼 데이터를 추출하는 것

### 2. Lazy loading

- SQLAlchemy는 기본적으로 데이터를 지연 로드(lazy loading) 방식으로 가져옵니다.
- 지연 로드란, 데이터를 쿼리 실행 시점이 아니라 필요한 시점에 메모리에 적재하는 방식입니다.
- 청크 단위로 데이터를 가져오는 경우, 데이터는 청크별로 순차적으로 메모리에 적재되고 사용된 후 해제됩니다.
## 청크단위 처리 방법

### 1. 스트리밍 옵션 (Streaming Results)

- SQLAlchemy에서 stream_results=True 옵션을 사용하면, 결과를 스트리밍 방식으로 처리할 수 있습니다.
- 이 옵션은 쿼리 실행 시 전체 결과를 한 번에 메모리에 로드하지 않고, 데이터를 스트리밍 방식으로 처리합니다.
- 예시
  ```python
  python
  코드 복사
  with engine.connect() as connection:
      result = connection.execution_options(stream_results=True).execute("SELECT * FROM large_table")
      for row in result:
          process_row(row)  # 한 행씩 처리
  ```

  - 데이터는 한 번에 한 행(row)씩 처리되므로 메모리 사용량이 최소화됩니다.
### 2. Fetch API를 활용한 청크 처리

- SQLAlchemy에서 제공하는 fetch API(fetchmany, fetchone, fetchall)를 통해 데이터를 단계적으로 처리할 수 있습니다.
- 주요 메서드:
  - fetchmany(size): 지정한 청크 크기만큼 데이터를 가져옴.
  - fetchone(): 한 번에 한 행만 가져옴.
  - fetchall(): 모든 결과를 가져옴 (큰 데이터셋에서는 권장하지 않음).
### Fetch API의 장점:

- 메모리 사용량을 청크 크기로 제한할 수 있음.
- 데이터 처리 중 데이터베이스와의 연결을 유지하면서 필요할 때 데이터를 추가로 가져옴.