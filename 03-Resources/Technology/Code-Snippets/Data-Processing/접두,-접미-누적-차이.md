---
title: "접두, 접미 누적 차이"
source: notion
notion_id: 27ec6d43-3b4d-8014-bf05-d4b38b24ad47
imported: 2025-11-29
database: 레퍼런스
하위 항목: []
구상기록: []
구분: []
링크: []
최종편집시각: "2025-09-30T02:29:00.000Z"
제목: ""
상위 항목: ["27ec6d43-3b4d-8003-aa76-f05acf123072"]
PARA: "Resource"
tags: ["레퍼런스", "notion-import"]
---

```sql
왜 LEAD(… ORDER BY ASC) → LAG(… ORDER BY DESC)?

수학적으로 동일:
LEAD(x) OVER (PARTITION BY k ORDER BY d ASC)
≡ LAG(x) OVER (PARTITION BY k ORDER BY d DESC)
(ASC에서 "다음 행" = DESC에서 "이전 행")

윈도우 프레임을 접기 쉬움:
원래는 CURRENT ROW ~ UNBOUNDED FOLLOWING = 접미 누적(미래까지 곱) 이라서 "뒤쪽 데이터"를 봐야 했고, 플래너가 덜 최적화합니다.
DESC로 뒤집고 UNBOUNDED PRECEDING ~ CURRENT ROW로 바꾸면 접두 누적(과거까지 곱) 이 되어 스트리밍/단일 패스로 계산이 쉬워져요.

정렬/메모리 비용↓:
(short_code, trade_date) 인덱스를 역방향 스캔하면 별도 정렬 없이 창 함수가 흘러가고, 미래행을 버퍼에 오래 쥐고 있을 필요가 없어 work_mem 스필 위험도 줄어요.

플래너 친화적:
PostgreSQL이 접두 누적 패턴을 더 잘 다룹니다(인크리멘털 소트, 백워드 인덱스 스캔 활용). 결과적으로 Sort/WindowAgg 앞의 대정렬·temp I/O가 크게 줄어듭니다.

운영 이점:
최근 구간만 증분 계산/머지할 때도 DESC+접두 누적이 구현이 간단하고 빠릅니다.

주의: 동일 trade_date에 다중 레코드가 있을 수 있으면 결정적 순서를 위해 ORDER BY trade_date DESC, standard_code 같은 보조 키를 추가하세요. 그래야 LAG/LEAD 치환이 완벽히 동일하게 작동합니다.
```

