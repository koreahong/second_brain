---
title: 세션과 커넥션
type: resource
tags:
- DB
---

## 개념

- 세션은 ORM을 활용하여 객체개념을 활용하여 DB를 관리하기 위해 사용하고, 커넥션은 DB에 직접 붙어서 DB에 쿼리를 활용할 때 사용하는 것,
## 목적

- 세션과 커넥션 비교를 통해서 ETL에 적합한 방식을 적용하기 위함
## 세션과 커텍션 비교

- 세션은 SQLAlchemy의 **ORM(Object Relational Mapper)**에서 데이터베이스 작업을 관리하는 고수준의 인터페이스
- 커넥션은 SQLAlchemy Core에서 데이터베이스와의 직접적인 연결을 나타냄
## 언제 세션을 사용하고, 언제 커넥션을 사용할까?

### 세션 사용

- ORM을 사용할 때: 객체-관계 매핑이 필요하고 Python 클래스와 데이터베이스 간 작업이 많을 때.
- 복잡한 데이터 상태 관리: 트랜잭션을 자동으로 관리하고, 관련 객체를 효율적으로 처리해야 할 때.
- Lazy Loading이 필요한 경우: 데이터가 필요한 순간에만 데이터베이스에서 가져오고 싶을 때.
### 커넥션 사용

- Raw SQL 작업: SQLAlchemy Core에서 SQL 쿼리를 직접 실행해야 할 때.
- 고성능 데이터 처리: 대규모 데이터 작업이나 ORM 오버헤드 없이 데이터베이스와 직접 상호작용해야 할 때.
- 트랜잭션 세부 제어: 복잡한 트랜잭션 처리(부분 커밋, 롤백 등)가 필요한 경우.
## ORM 오버헤드의 주요 원인

### 1. 데이터 매핑 비용

- ORM은 데이터베이스의 테이블 행(row)을 Python 객체로 변환합니다. 이 과정에서:
  1. 데이터를 객체로 생성하고,
  1. 객체의 속성과 데이터베이스 열(column)을 매핑하며,
  1. 상태를 추적합니다 (예: 새로 생성된 객체인지, 수정된 객체인지 등).
- 이러한 매핑 과정은 단순히 SQL 결과를 받아 사용하는 것보다 더 많은 연산을 필요로 합니다.
- ORM은 쿼리 결과를 Python 객체로 변환하는 추가 작업이 있으므로 더 많은 CPU 자원을 사용합니다.
- ORM의 오버헤드는 객체 매핑, 상태 관리, Lazy Loading, 쿼리 생성 등의 추가 작업에서 발생하며, 이는 대량 데이터 처리 또는 고성능이 요구되는 작업에서 문제가 될 수 있습니다.
## ORM 상태관리

### 1. 개념

- 상태 관리(State Management)는 SQLAlchemy ORM에서 중요한 개념 중 하나로, 데이터베이스와 매핑된 Python 객체가 현재 어떤 상태에 있는지 추적하고 관리하는 작업을 의미합니다. SQLAlchemy는 객체를 데이터베이스와 동기화하고 변경 사항을 효율적으로 처리하기 위해 각 객체의 상태를 지속적으로 추적하는 것 
### 2. 케이스

- Transient: SQLAlchemy 세션에 연결되지 않은 객체
- Pending: 세션에 추가되었지만, 데이터베이스에 아직 기록되지 않은 객체
- Persistent: 객체가 데이터베이스에 저장되어 있고, 세션에서 관리되고 있는 상태
- Detached: 더 이상 세션에서 관리하지 않는 객체
### 결론

- 위 상태를 관리하는 이유는 결론적으로 변경 사항에 따른 SQL를 생성하기 위함임