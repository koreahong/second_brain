---
title: "객체지향 패러다임"
source: notion
notion_id: 155c6d43-3b4d-80f7-9673-d1fd2b95bfe6
imported: 2025-11-29
database: 레퍼런스
하위 항목: []
구상기록: []
구분: ["객체지향"]
링크: []
최종편집시각: "2024-12-07T04:12:00.000Z"
제목: ""
상위 항목: []
tags: ["레퍼런스", "객체지향", "notion-import"]
---

## 개념

- 객체지향 패러다임은 사물을 이해하는 방식을 객체단위로 생각하고 이를 프로그래밍하는 기법을 뜻함.
## 목적

- 코드를 더욱 유연성있게 만들어 유지보수와 관리를 더욱 용이하게 하기 위함
## 서칭내용

### 클래스

- 객체를 만들기 위한 설계도예요. 예를 들어, 강아지 클래스는 모든 강아지가 가질 수 있는 속성과 동작
### 객체

- 클래스로부터 실제로 만들어진 실체예요. 예를 들어, "보리"라는 이름의 강아지는 강아지 클래스의 객체
### 캡슐화

- 객체의 내부 속성을 직접적으로 변경할 수 없게 막고, 정해진 메서드를 통해서만 속성을 변경하거나 접근할 수 있게 하는 것이에요. 이렇게 하면 속성값이 예상치 못하게 변경되는 것을 방지하고, 객체의 상태를 안정적으로 유지
  ```python
  class Dog:
      def __init__(self, name, age, color):
          self.__name = name   # 비공개 속성
          self.__age = age     # 비공개 속성
          self.color = color    # 공개 속성
      
      # 이름을 가져오는 메서드 (getter)
      def get_name(self):
          return self.__name
      
      # 이름을 바꾸는 메서드 (setter)
      def set_name(self, new_name):
          self.__name = new_name
      
      # 나이를 가져오는 메서드 (getter)
      def get_age(self):
          return self.__age
      
      # 나이를 바꾸는 메서드 (setter)
      def set_age(self, new_age):
          if new_age > 0:
              self.__age = new_age
          else:
              print("나이는 0보다 커야 해요!")
      
      def bark(self):
          print(f"{self.__name}가(이) 멍멍 짖어요!")
      
      def eat(self, food):
          print(f"{self.__name}가(이) {food}을(를) 먹어요.")
          
          
   위에 비공개 속성은 반드시 정의된 매서드를 통해서만 속성값을 바꿀 수 있음
  ```

### 상속

- 상속은 기존에 있는 클래스(부모 클래스)를 기반으로 새로운 클래스(자식 클래스)를 만드는 것을 말해요. 자식 클래스는 부모 클래스의 속성과 동작을 물려받을 수 있어요. 이렇게 하면 코드를 재사용할 수 있어서 편리해요.
  ```python
  class Dog:
      def __init__(self, name, age, color):
          self.name = name
          self.age = age
          self.color = color
      
      def bark(self):
          print(f"{self.name}가(이) 멍멍 짖어요!")
      
      def eat(self, food):
          print(f"{self.name}가(이) {food}을(를) 먹어요.")
  
  # Dog 클래스를 상속받은 Bulldog 클래스
  class Bulldog(Dog):
      def __init__(self, name, age, color, snore_volume):
          super().__init__(name, age, color)  # 부모 클래스의 초기화 메서드 호출
          self.snore_volume = snore_volume  # Bulldog만의 새로운 속성
      
      def snore(self):
          print(f"{self.name}가(이) {self.snore_volume}으로 코를 골아요!")
  ```

### 다형성 

- 다형성은 같은 이름의 메서드가 여러 클래스에서 다른 동작을 하는 것을 말해요. 이렇게 하면 같은 메서드를 사용하지만, 객체의 종류에 따라 다르게 동작할 수 있어요.
  ```python
  class Animal:
      def make_sound(self):
          pass  # 아무 것도 하지 않아요
  
  class Dog(Animal):
      def make_sound(self):
          print("멍멍!")
  
  class Cat(Animal):
      def make_sound(self):
          print("야옹!")
  
  class Cow(Animal):
      def make_sound(self):
          print("음매!")
  
  # 다양한 동물 객체 만들기
  animals = [Dog(), Cat(), Cow()]
  
  for animal in animals:
      animal.make_sound()
  ```

### 추상화 

- 추상화는 복잡한 시스템을 단순하게 표현하는 것을 말해요. 필요한 부분만 보여주고, 불필요한 부분은 숨겨요. 객체의 공통적인 속성과 기능을 추출하여 정의하는것을 의미합니다.

클래스를 설계할 때, 모든 가능한 속성과 메서드를 포함시키지 않고, 필요한 것만을 선택하여 정의하는 것도 추상화의 한 형태예요.

