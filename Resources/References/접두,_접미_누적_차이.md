---
title: 접두, 접미 누적 차이
created: 2025-11-28
tags: ["reference", "migrated", "resource"]
PARA: Resource
구분: []
---

# 접두, 접미 누적 차이

## 📝 내용

```sql
왜 LEAD(… ORDER BY ASC) → LAG(… ORDER BY DESC)?

수학적으로 동일:
LEAD(x) OVER (PARTITION BY k ORDER BY d ASC)
≡ LAG(x) OVER (PARTITION BY k ORDER BY d DESC)
(ASC에서 "다음 행" = DESC에서 "이전 행")

윈도우 프레임을 접기 쉬움:
원래는 CURRENT ROW ~ UNBOUNDED FOLLOWING = 접미 누적(미래까지 곱) 이라서 "뒤쪽 데이터"를 봐야 했고, 플래너가 덜 최적화합니다.
DESC로 뒤집고 UNBOUNDED PRECEDING ~ CURRENT ROW로 바꾸면 접두 누적(과거까지 곱) 이 되어 스트리밍/단일 패스로 계산이 쉬워져요.

정렬/메모리 비용↓:
(short_code, trade_date) 인덱스를 역방향 스캔하면 별도 정렬 없이 창 함수가 흘러가고, 미래행을 버퍼에 오래 쥐고 있을 필요가 없어 work_mem 스필 위험도 줄어요.

플래너 친화적:
PostgreSQL이 접두 누적 패턴을 더 잘 다룹니다(인크리멘털 소트, 백워드 인덱스 스캔 활용). 결과적으로 Sort/WindowAgg 앞의 대정렬·temp I/O가 크게 줄어듭니다.

운영 이점:
최근 구간만 증분 계산/머지할 때도 DESC+접두 누적이 구현이 간단하고 빠릅니다.

주의: 동일 trade_date에 다중 레코드가 있을 수 있으면 결정적 순서를 위해 ORDER BY trade_date DESC, standard_code 같은 보조 키를 추가하세요. 그래야 LAG/LEAD 치환이 완벽히 동일하게 작동합니다.
```

## 🏷️ 분류

- **PARA**: Resource
- **구분**: 없음

## 🔗 연결

**활용 프로젝트**:
- (아직 없음)

**관련 레퍼런스**:
- (아직 없음)

---

*Notion에서 재마이그레이션됨 (2025-11-28)*
