---
title: SQLP
created: 2025-07-21
tags: ["reference", "migrated", "project", "sqlp"]
PARA: Project
구분: ["SQLP"]
---

# SQLP

## 📝 내용

In 으로 되어 있으면 skip scan 사용 못함

인덱스와 select list가 동일하면 풀 스캔 사용 사능

스킺 스캔은 선두컬럼이 있어도 사용가능. 선택도가 높은 경우에

힌트에 인덱스에 포함된 컬럼 명시 가능

인덱스 브랜치 블록에는 하위 블록의 키값의 범위가 저장되어 있음

복합인덱스일 경우 null도 저장하는데 구성된 컬럼 중 한개라도 반드시 not null 조건이어야 is null을 해도 range 인덱스를 사용할 수 있음

Range scan은 선두컬럼을 가공허지 않고 사용하면 가능하다

Use concat은 or나 in을 union all로 나눌 수 있음

Rowing batched여도 sort가 나타나지 않았다면 부분처리가 가능함

Skip scan은 선두컬럼의 ndv가 낮을 수록 유리함

집계를 생략허기 위해서 covering용으로 인덱스에 추가할 수 있음 -  sqlp1권 88p 57번

부분처리가 가능하다는 것은 정렬 연산을 생략할 수 있다는 것

Skip scan이 일어나면 정렬이 깨짐. Skip이 일어난 컬럼의 각 값에 대해서는 정렬이 되어 있으나 모든 결과물들에 대한 정렬은 보장하지 못함. Sqlp 1 89 59

첫 비동등조건까지만 순서가 유지됨. 그 이유는 비동등 조건은 같은 비종등조건 컬럼값 안에서 이후의 값을 정렬한 것이기 때문. 비동등이면 같은 값이 아니라 여러 값을 가져오기 때문에 이후 컬럼이 인덱스에 있다고 해서 정렬을 보장할 수 없음 sqlp1 89 58

인덱스 엑세스는 첫 비동등조건까지 사용

인덱스 필터는 인덱스 블록을 읽으면서 인덱스 블록을 필터링 함

테이블 필터는 랜덤엑세스로 테이블을 읽고 필터링함

조인조건절이 대한 인덱스를 구성할때 일반조건과 조인조건 모두 =연산자이면 순서는 상관 없음. 단, =이 아닐경우 분포에 따라서 순서를 정해야함. 부등호라도 분포가 더 적으면 =보다 먼저 배치할 수 있음 sqlp1 138 13

소트조인은 pga에서 진행한다. 다만, 드라이빙 테이블의 조인컬럼이 인덱스에 있으면 정렬을 하지않고 바로 진행하지만 inner 테이블은 반드시 pga에 조인컬럼기준으로 정랼 후 조인을 진행한다. 인덱스가 있다고 하더라도. Pga에서 읽기 때문에 빠른 것. Sqlp1 142 19

해쉬조인을 할때 따로 언급을 안하면 build input은 leading 순서 sqlp1 149 33

해쉬조인을 할때 조인한 테이블을 build input으로 쓰고 싶을때는 다른쪽 테이블을 no swap join inputs 힌트로 지정하면된다.

Build input인 테이블이 실행계확상 더 위에 있다

해쉬조인은 =이 하나 이상 반드시 있어야 사용할 수 있다. =조건 하나가지고 해쉬맵을 만들기 때문. 그래서 =이 많아면 많을 수록 해쉬맵에 충돌이 덜 발생한다. 해쉬는 같은 값을 찾기 위해 만들어져서 범위로 찾을 경우에는 검색이 불가능함. Sqlp1 147 28

No unnest는 스칼라 서브쿼리에 쓰는 힌트고 no merge push pred는 인라인뷰에 쓰는 것이다. 스칼라 서브쿼리를 인라이뷰로 옮기고 할때는 반드시 outer 조인을 해야한다는 것을 명심할 것. Push pred를 하는 이유는 스칼라 서브쿼리가 진행할때 불필요한 데이터를 먼저 필터링을 하여 더 효율을 높이기 위함 sqlp1 159 44

스칼라 서브쿼리를 작성할때 카디널리티 관계를 확인해야함. 메인대 서브쿼리가 m:1일 경우 집계가 필요없지만 반대는 필요하다. Sqlp1 155 39

스칼라 서브쿼리는 실행계획에서 메인 쿼리보다 위에 있다. Sqlp1 157 42

Hash join을 할때 작은 테이블에 full 힌트를 사용해서 최적화 가능

서브쿼리를 unnest해서 드라이빙으로 사용된다면 sort unique 연산으로 unique한 집합을 생성한 후에 조인함, 아니면 원래 메인 테이블이 드라이빙할 경우에는 세미 조인으로 진행함 sqlp1 232 27

서브쿼리를 no_unnest하묜 무조건 메인 테이블이 드라이빙 테이블이 되어서 실행계획 위에 있다. Sqlp1 232 28

Push supq는 서브쿼리 필토링을 가능한 앞 단계에서 진행하라는 명령어, 반대로 no Push supq는 가능한 늦게 sqlp1 236 33

View 머징이 일어나지 않으면 실행계획에 view라고 써있고 push pred가 적용되면 push predicate가 뜬다. 뷰머징이 작용되면 일반 테이블 취급하여 위의 것들이 나타나지 않음 sqlp1 238 35

Use concat은 or를 union all으로 변환, no_expand는 방지

Stopkey는 인덱스로 정렬을 스킵하면서 원하는 조건에 부합하는 데이터를 빨리 찾는 것이다. 정렬을 안하는 방식으로 코드를 짜고 나머지컬럼은 테이블엑세스를 하더라도 행을 빨리 찾는게 이득일 경우에 사용하면 좋다 sqlp2 28 17

## 🏷️ 분류

- **PARA**: Project
- **구분**: SQLP

## 🔗 연결

**Hub**: [[_HUB_Database]], [[_HUB_Learning]], [[_HUB_Coding]], [[_HUB_Data_Architecture]]

**활용 프로젝트**:
- (아직 없음)

**관련 레퍼런스**:
- (아직 없음)

---

*Notion에서 재마이그레이션됨 (2025-11-28)*
